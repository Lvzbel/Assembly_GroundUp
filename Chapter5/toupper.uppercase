#PURPOSE:		THIS PROGRAM CONVERTS AND INPUT FILE
#				TO AN OUTPUT FILE WITH ALL LETTERS
#				CONVERTED TO UPPERCASE.
#
#PROCESSING:	1) OPEN THE INPUT FILE
#				2) OPEN THE OUTPUT FILE
#				3) WHILE WE'RE NOT AT THE END OF THE INPUT FILE
#					A) READ PART OF THE FILE INTO OUR PIECE OF MEMORY
#					B) GO THROUGHT EACH BYTE OF MEMORY
#						IF THE BYTE IS A LOWER-CASE LETTER, CONVERT IT TO UPPERCASE
#					C) WRITE THE PIECE OF MEMORY TO THE OUTPUT FILE

.SECTION .DATA	#WE ACTUALLY DONT PUT ANYTHING IN THE DATA SECTION IN
				#THIS PROGRAM, BUT IT'S HERE FOR COMPLETENESS

#######CONSTANTS#######

#SYSTEM CALL NUMBERS
.EQU	OPEN, 5
.EQU 	WRITE, 4
.EQU 	READ, 3
.EQU 	CLOSE, 6
.EQU 	EXIT, 1

#OPTIONS FOR OPEN	(LOOK AT /USR/INCLUDE/ASM/FCNTL.H FOR
#					VARIOUS VALUES. YOU CAN COMBINE THEM
#					BY ADDING THEM)
.EQU 	O_RDONLY, 0					#OPEN FILE OPTIONS - READ-ONLY
.EQU 	O_CREAT_WRONGLY_TRUNC, 03101#OPEN FILE OPTIONS - THESE OPTIONS ARE:
									#CREAT - CREATE FILE IF IT DOESN'T EXIST
									#WRONGLY - WE WILL ONLY WRITE TO THIS FILE
									#TRUNC - DESTROY CURRENT FILE CONTENTS, IF ANY EXIST

#SYSTEM CALL INTERRUPT
.EQU 	LINUX_SYSCALL, 0X80

#END-OF-FILE RESULT STATUS
.EQU 	END_OF_FILE, 0		#THIS IS THE RETURN VALUE OF READ() WHICH
							#MEANS WE'VE HIT THE END OF THE FILE

#######BUFFERS#######

.SECTION .BSS
#THIS IS WHERE THE DATA IS LOADED INTO FORM
#THE DATA FILE AND WRITTEN FROM INTO THE OUTPUT FILE. THIS
#SHOULD NEVER EXCEED 16,000 FOR VARIOUS REASONS.
.EQU 	BUFFER_SIZE, 500
.LCOMM	BUFFER_DATA, BUFFER_SIZE 


#######PROGRAM CODE#######

.SECTION .TEXT

#STACK POSITIONS
.EQU 	ST_SIZE_RESERVE, 8
.EQU 	ST_FD_IN, 0
.EQU 	ST_FD_OUT, 4
.EQU 	ST_ARGC, 8		#NUMBER OF ARGUMENTS
.EQU 	ST_ARGC_0, 12	#NAME OF PROGRAM
.EQU 	ST_ARGC_1, 16	#INPUT FILE NAME	
.EQU 	ST_ARGC_2, 20	#OUTPUT FILE NAME

.GLOBL _START
_START:
###INITIALIZE PROGRAM###
SUBL	$ST_SIZE_RESERVE, %ESP		#ALLOCATE SPACE FOR OUR POINTERS ON THE STACK
MOVL	%ESP, %EBP

OPEN_FILES:
OPEN_FD_IN:
###OPEN INPUT FILE###
MOVL 	ST_ARGC_1(%EBP), %EBX		#INPUT FILENAME INTO %EBX
MOVL 	$O_RDONLY, %ECX				#READ-ONLY FLAG
MOVL 	$0666, %EDX					#THIS DOESN'T REALLY MATTER FOR READING
MOVL 	$OPEN, %EAX 				#OPEN SYSCALL
INT		$LINUX_SYSCALL 				#CALL LINUX

STORE_FD_IN:
MOVL 	%EAX, ST_FD_IN(%EBP) 		#SAVE THE GIVEN FILE DESCRIPTOR

OPEN_FD_OUT:
###OPEN OUTPUT FILE###
MOVL 	ST_ARGC_2(%EBP), %EBX 		#OUTPUT FILENAME INTO %EBX
MOVL 	$O_CREAT_WRONGLY_TRUNC, %ECX #FLAGS FOR WRITING TO THE FILE
MOVL 	$0666, %EDX 				#MODE FOR NEW FILE (IF IT'S CREATED)
MOVL 	$OPEN, %EAX 				#OPEN THE FILE
INT 	$LINUX_SYSCALL 				#CALL LINUX

STORE_FD_OUT:
MOVL 	%EAX, ST_FD_OUT(%EBP) 		#STORE THE FILE DESCRIPTOR HERE

###BEGIN MAIN LOOP###
READ_LOOP_BEGIN:

###READ IN A BLOCK FROM THE INPUT FILE###
MOVL 	ST_FD_IN(%EBP), %EBX 		#GET THE INPUT FILE DESCRIPTOR
MOVL 	$BUFFER_DATA, %ECX 			#THE LOCATION TO READ INTO
MOVL 	$BUFFER_SIZE, %EDX 			#THE SIZE OF THE BUFFER
MOVL 	$READ, %EAX 
INT 	$LINUX_SYSCALL 				#SIZE OF BUFFER READ IS
									#RETURNED IN %EAX

###EXIT IF WE'VE REACHED THE END##
CMPL 	$END_OF_FILE, %EAX 			#CHECK FOR END OF FILE MAKER
JLE 	END_LOOP 					#IF FOUND, GO TO THE END

CONTINUE_READ_LOOP:
###CONVERT THE BLOCK TO UPPER CASE###
PUSHL 	$BUFFER_DATA 				#LOCATION OF THE BUFFER
PUSHL 	%EAX 						#SIZE OF THE BUFFER
CALL 	CONVERT_TO_UPPER
POPL 	%EAX
POPL 	%EBX

###WRITE THE BLOCK OUT TO THE OUTPUT FILE###
MOVL 	ST_FD_OUT(%EBP), %EBX 		#FILE TO USE
MOVL 	$BUFFER_DATA, %ECX 			#LOCATION OF THE BUFFER
MOVL 	%EAX, %EDX 					#SIZE OF THE BUFFER
MOVL 	$WRITE, %EAX
INT 	$LINUX_SYSCALL 

###CONTINUE THE LOOP###
JMP READ_LOOP_BEGIN 

END_LOOP:
###CLOSE THE FILES###
#NOTE - WE DONT NEED TO DO ERROR CHECKING ON THESE, BECAUSE
#		ERROR CONDITIONS DONT'T SIGNIFY ANYTHING SPECIAL HERE
MOVL 	ST_FD_OUT(%EBP), %EBX
MOVL 	$CLOSE, %EAX
INT 	$LINUX_SYSCALL

MOVL 	ST_FD_IN(%EBP), %EBX
MOVL 	$CLOSE, %EAX
INT 	$LINUX_SYSCALL

###EXIT###
MOVL 	$0, %EBX
MOVL 	$EXIT, %EAX
INT 	$LINUX_SYSCALL

######FUCNTION CONVERT_TO_UPPER
#
#PURPOSE:	THIS FUNCTION ACTUALLY DOES THE CONVERSION TO UPPER CASE FOR A BLOCK
#
#INPUT: 	THE FIRST PARAMETER IS THE LCATION OF THE BLOCK OF MEMORY TO CONVERT
#			THE SECOND PARAMTER IS THE LENGTH OF THAT BUFFER
#
#OUTPUT: 	THIS FUNCTION OVERWRITES THE CURRENT BUFFER WITH THE UPPER-CASIFIED
#			VERSION.
#
#VARIABLES:
#			%EAX - BEGINNING OF BUFFER
#			%EBX - LENGTH OF BUFFER
# 			%EDI - CURRENT BUFFER OFFSET
#			%CL - CURRENT BYTE BEING EXAMINED (%CL IS THE FIRST BYTE OF %ECX)
#

##CONSTANTS##
.EQU 	LOWERCASE_A, 'A'			#THE LOWER BOUNDARY OF OUR SEARCH
.EQU 	LOWERCASE_Z, 'Z'			#THE UPPER BOUNDARY OF OUR SEARCH
.EQU 	UPPER_CONVERSION, 'A' - 'A' #CONVERSION BETWEEN UPPER AND LOWER CASE

###STACK POSITION###
.EQU 	ST_BUFFER_LEN, 8 			#LENGHT OF BUFFER
.EQU 	ST_BUFFER, 12 				#ACTUAL BUFFER
CONVERT_TO_UPPER:
PUSHL 	%EBP
MOVL 	%ESP, %EBP

###SET UP VARIBLES###
MOVL 	ST_BUFFER(%EBP), %EAX
MOVL 	ST_BUFFER_LEN(%EBP), %EBX
MOVL 	$0, %EDI

#IF A BUFFER WITH ZERO LENGHT WAS GIVEN US, JUST LEAVE
CMPL 	$0, %EBX
JE 		END_CONVERT_LOOP

CONVERT_LOOP:
#GET THE CURRENT BYTE
MOVB 	(%EAX,%EDI,1), %CL

#GO TO THE NEXT BYTE UNLESS IT IS BETWEEN 'A' AND 'Z'
CMPB	$LOWERCASE_A, %CL
JL 		NEXT_BYTE
CMPB 	$LOWERCASE_Z, %CL
JG 		NEXT_BYTE 

#OTHERWISE CONVERT THE BYTE TO UPPERCASE
ADDB	$UPPER_CONVERSION, %CL
#AND STORE IT BACK
MOVB 	%CL, (%EAX,%EDI,1)
NEXT_BYTE:
INCL 	%EDI 						#NEXT BYTE
CMPL 	%EDI, %EBX 					#CONTINUE UNLESS WE'VE REACHED THE END
JNE 	CONVERT_LOOP

END_CONVERT_LOOP:
#NO RETURN VALUE, JUST LEAVE
MOVL 	%EBP, %ESP
POPL 	%EBP
RET
